// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: conversations.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createConversation = `-- name: CreateConversation :one
INSERT INTO conversations (type)
VALUES ($1)
RETURNING id, type, name, description, avatar_url, created_at, updated_at, last_message_at
`

func (q *Queries) CreateConversation(ctx context.Context, type_ string) (Conversation, error) {
	row := q.db.QueryRow(ctx, createConversation, type_)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.Description,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastMessageAt,
	)
	return i, err
}

const findDirectConversation = `-- name: FindDirectConversation :one
SELECT c.id, c.type, c.name, c.description, c.avatar_url, c.created_at, c.updated_at, c.last_message_at
FROM conversations c
WHERE c.type = 'direct'
    AND EXISTS (
        SELECT 1 FROM conversation_participants cp1
        WHERE cp1.conversation_id = c.id AND cp1.user_id = $1 AND cp1.is_active = true
    )
    AND EXISTS (
        SELECT 1 FROM conversation_participants cp2
        WHERE cp2.conversation_id = c.id AND cp2.user_id = $2 AND cp2.is_active = true
    )
    AND (
        SELECT COUNT(*) FROM conversation_participants cp
        WHERE cp.conversation_id = c.id AND cp.is_active = true
    ) = 2
`

type FindDirectConversationParams struct {
	UserID   pgtype.UUID
	UserID_2 pgtype.UUID
}

func (q *Queries) FindDirectConversation(ctx context.Context, arg FindDirectConversationParams) (Conversation, error) {
	row := q.db.QueryRow(ctx, findDirectConversation, arg.UserID, arg.UserID_2)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.Description,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastMessageAt,
	)
	return i, err
}

const getUserConversations = `-- name: GetUserConversations :many
SELECT
    c.id, c.type, c.name, c.description, c.avatar_url, c.created_at, c.updated_at, c.last_message_at,
    m.content as last_message_content,
    m.created_at as last_message_created_at,
    sender.name as last_message_sender_name
FROM conversations c
JOIN conversation_participants cp ON c.id = cp.conversation_id
LEFT JOIN messages m ON c.id = m.conversation_id
    AND m.created_at = c.last_message_at
LEFT JOIN users sender ON m.sender_id = sender.id
WHERE cp.user_id = $1 AND cp.is_active = true
ORDER BY c.last_message_at DESC
`

type GetUserConversationsRow struct {
	ID                    pgtype.UUID
	Type                  string
	Name                  pgtype.Text
	Description           pgtype.Text
	AvatarUrl             pgtype.Text
	CreatedAt             pgtype.Timestamptz
	UpdatedAt             pgtype.Timestamptz
	LastMessageAt         pgtype.Timestamptz
	LastMessageContent    pgtype.Text
	LastMessageCreatedAt  pgtype.Timestamptz
	LastMessageSenderName pgtype.Text
}

func (q *Queries) GetUserConversations(ctx context.Context, userID pgtype.UUID) ([]GetUserConversationsRow, error) {
	rows, err := q.db.Query(ctx, getUserConversations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserConversationsRow
	for rows.Next() {
		var i GetUserConversationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Name,
			&i.Description,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastMessageAt,
			&i.LastMessageContent,
			&i.LastMessageCreatedAt,
			&i.LastMessageSenderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateConversationLastMessageAt = `-- name: UpdateConversationLastMessageAt :exec
UPDATE conversations
SET
    last_message_at = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateConversationLastMessageAtParams struct {
	ID            pgtype.UUID
	LastMessageAt pgtype.Timestamptz
}

func (q *Queries) UpdateConversationLastMessageAt(ctx context.Context, arg UpdateConversationLastMessageAtParams) error {
	_, err := q.db.Exec(ctx, updateConversationLastMessageAt, arg.ID, arg.LastMessageAt)
	return err
}
