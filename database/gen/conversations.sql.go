// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: conversations.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createConversation = `-- name: CreateConversation :one
INSERT INTO conversations (type)
VALUES ($1)
RETURNING id, type, name, description, avatar_url, created_at, updated_at, last_message_at
`

func (q *Queries) CreateConversation(ctx context.Context, type_ string) (Conversation, error) {
	row := q.db.QueryRow(ctx, createConversation, type_)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.Description,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastMessageAt,
	)
	return i, err
}

const findDirectConversation = `-- name: FindDirectConversation :one
SELECT c.id, c.type, c.name, c.description, c.avatar_url, c.created_at, c.updated_at, c.last_message_at
FROM conversations c
WHERE c.type = 'DIRECT'
    AND EXISTS (
        SELECT 1 FROM conversation_participants cp1
        WHERE cp1.conversation_id = c.id AND cp1.user_id = $1 AND cp1.is_active = true
    )
    AND EXISTS (
        SELECT 1 FROM conversation_participants cp2
        WHERE cp2.conversation_id = c.id AND cp2.user_id = $2 AND cp2.is_active = true
    )
    AND (
        SELECT COUNT(*) FROM conversation_participants cp
        WHERE cp.conversation_id = c.id AND cp.is_active = true
    ) = 2
`

type FindDirectConversationParams struct {
	UserID   pgtype.UUID
	UserID_2 pgtype.UUID
}

func (q *Queries) FindDirectConversation(ctx context.Context, arg FindDirectConversationParams) (Conversation, error) {
	row := q.db.QueryRow(ctx, findDirectConversation, arg.UserID, arg.UserID_2)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.Description,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastMessageAt,
	)
	return i, err
}

const getLastMessage = `-- name: GetLastMessage :many

WITH ranked_messages AS (
    SELECT
        m.id,
        m.conversation_id,
        m.sender_id,
        m.content,
        m.message_type,
        m.reply_to_message_id,
        m.status,
        m.created_at,
        m.edited_at,
        m.delivered_at,
        m.read_at,
        sender.name as sender_name,
        sender.avatar_url as sender_avatar_url,
        sender.email as sender_email,
        sender.created_at as sender_created_at,
        sender.updated_at as sender_updated_at,
        ROW_NUMBER() OVER (PARTITION BY m.conversation_id ORDER BY m.created_at DESC) as rn
    FROM messages m
    JOIN users sender ON m.sender_id = sender.id
    WHERE m.conversation_id = ANY($1::uuid[])
)
SELECT
    id,
    conversation_id,
    sender_id,
    content,
    message_type,
    edited_at,
    status,
    reply_to_message_id,
    created_at,
    delivered_at,
    read_at,
    sender_name,
    sender_avatar_url,
    sender_email,
    sender_created_at,
    sender_updated_at
FROM ranked_messages
WHERE rn = 1
ORDER BY created_at DESC
`

type GetLastMessageRow struct {
	ID               pgtype.UUID
	ConversationID   pgtype.UUID
	SenderID         pgtype.UUID
	Content          string
	MessageType      string
	EditedAt         pgtype.Timestamptz
	Status           string
	ReplyToMessageID pgtype.UUID
	CreatedAt        pgtype.Timestamptz
	DeliveredAt      pgtype.Timestamptz
	ReadAt           pgtype.Timestamptz
	SenderName       pgtype.Text
	SenderAvatarUrl  pgtype.Text
	SenderEmail      string
	SenderCreatedAt  pgtype.Timestamptz
	SenderUpdatedAt  pgtype.Timestamptz
}

// -- name: GetConversationParticipants :many
// SELECT
//
//	cp.id,
//	cp.conversation_id,
//	cp.user_id,
//	cp.joined_at,
//	cp.last_read_at,
//	cp.is_active,
//	u.id as user_id,
//	u.name as user_name,
//	u.avatar_url as user_avatar_url
//
// FROM conversation_participants cp
// JOIN users u ON cp.user_id = u.id
// WHERE cp.conversation_id = ANY($1::uuid[])
//
//	AND cp.is_active = true
//
// ORDER BY cp.joined_at ASC;
func (q *Queries) GetLastMessage(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetLastMessageRow, error) {
	rows, err := q.db.Query(ctx, getLastMessage, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLastMessageRow
	for rows.Next() {
		var i GetLastMessageRow
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.EditedAt,
			&i.Status,
			&i.ReplyToMessageID,
			&i.CreatedAt,
			&i.DeliveredAt,
			&i.ReadAt,
			&i.SenderName,
			&i.SenderAvatarUrl,
			&i.SenderEmail,
			&i.SenderCreatedAt,
			&i.SenderUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserConversations = `-- name: GetUserConversations :many
SELECT
    c.id,
    c.type,
    c.last_message_at,
    c.created_at,
    c.updated_at,
    (
        SELECT COUNT(*)::INTEGER
        FROM messages unread_m
        WHERE unread_m.conversation_id = c.id
            AND unread_m.created_at > cp.last_read_at
            AND unread_m.sender_id != $1
    ) as unread_count
FROM conversations c
JOIN conversation_participants cp ON c.id = cp.conversation_id
WHERE cp.user_id = $1 AND cp.is_active = true
ORDER BY c.last_message_at DESC NULLS LAST
`

type GetUserConversationsRow struct {
	ID            pgtype.UUID
	Type          string
	LastMessageAt pgtype.Timestamptz
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	UnreadCount   int32
}

func (q *Queries) GetUserConversations(ctx context.Context, senderID pgtype.UUID) ([]GetUserConversationsRow, error) {
	rows, err := q.db.Query(ctx, getUserConversations, senderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserConversationsRow
	for rows.Next() {
		var i GetUserConversationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.LastMessageAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnreadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateConversationLastMessageAt = `-- name: UpdateConversationLastMessageAt :exec
UPDATE conversations
SET
    last_message_at = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateConversationLastMessageAtParams struct {
	ID            pgtype.UUID
	LastMessageAt pgtype.Timestamptz
}

func (q *Queries) UpdateConversationLastMessageAt(ctx context.Context, arg UpdateConversationLastMessageAtParams) error {
	_, err := q.db.Exec(ctx, updateConversationLastMessageAt, arg.ID, arg.LastMessageAt)
	return err
}
