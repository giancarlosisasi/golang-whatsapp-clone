// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: messages.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (
    conversation_id,
    sender_id,
    content,
    message_type,
    reply_to_message_id
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, conversation_id, sender_id, content, message_type, reply_to_message_id, media_url, media_filename, media_size, media_mime_type, location_latitude, location_longitude, location_address, is_deleted, created_at, edited_at, deleted_at
`

type CreateMessageParams struct {
	ConversationID   pgtype.UUID
	SenderID         pgtype.UUID
	Content          string
	MessageType      string
	ReplyToMessageID pgtype.UUID
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ConversationID,
		arg.SenderID,
		arg.Content,
		arg.MessageType,
		arg.ReplyToMessageID,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.ReplyToMessageID,
		&i.MediaUrl,
		&i.MediaFilename,
		&i.MediaSize,
		&i.MediaMimeType,
		&i.LocationLatitude,
		&i.LocationLongitude,
		&i.LocationAddress,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.EditedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getConversationMessages = `-- name: GetConversationMessages :many
SELECT
    m.id, m.conversation_id, m.sender_id, m.content, m.message_type, m.reply_to_message_id, m.media_url, m.media_filename, m.media_size, m.media_mime_type, m.location_latitude, m.location_longitude, m.location_address, m.is_deleted, m.created_at, m.edited_at, m.deleted_at,
    sender.id as sender_id,
    sender.name as sender_name,
    sender.email as sender_email,
    sender.avatar_url as sender_avatar_url,
    sender.created_at as sender_created_at,
    sender.updated_at as sender_updated_at,
    reply_msg.id as reply_id,
    reply_msg.content as reply_content,
    reply_msg.message_type as reply_message_type,
    reply_sender.name as reply_sender_name
FROM messages m
JOIN users sender ON m.sender_id = sender.id
LEFT JOIN messages reply_msg ON m.reply_to_message_id = reply_msg.id
LEFT JOIN users reply_sender ON reply_msg.sender_id = reply_sender.id
WHERE m.conversation_id = $1
ORDER BY m.created_at DESC
LIMIT $2 OFFSET $3
`

type GetConversationMessagesParams struct {
	ConversationID pgtype.UUID
	Limit          int32
	Offset         int32
}

type GetConversationMessagesRow struct {
	ID                pgtype.UUID
	ConversationID    pgtype.UUID
	SenderID          pgtype.UUID
	Content           string
	MessageType       string
	ReplyToMessageID  pgtype.UUID
	MediaUrl          pgtype.Text
	MediaFilename     pgtype.Text
	MediaSize         pgtype.Int8
	MediaMimeType     pgtype.Text
	LocationLatitude  pgtype.Numeric
	LocationLongitude pgtype.Numeric
	LocationAddress   pgtype.Text
	IsDeleted         pgtype.Bool
	CreatedAt         pgtype.Timestamptz
	EditedAt          pgtype.Timestamptz
	DeletedAt         pgtype.Timestamptz
	SenderID_2        pgtype.UUID
	SenderName        pgtype.Text
	SenderEmail       string
	SenderAvatarUrl   pgtype.Text
	SenderCreatedAt   pgtype.Timestamptz
	SenderUpdatedAt   pgtype.Timestamptz
	ReplyID           pgtype.UUID
	ReplyContent      pgtype.Text
	ReplyMessageType  pgtype.Text
	ReplySenderName   pgtype.Text
}

func (q *Queries) GetConversationMessages(ctx context.Context, arg GetConversationMessagesParams) ([]GetConversationMessagesRow, error) {
	rows, err := q.db.Query(ctx, getConversationMessages, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversationMessagesRow
	for rows.Next() {
		var i GetConversationMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ReplyToMessageID,
			&i.MediaUrl,
			&i.MediaFilename,
			&i.MediaSize,
			&i.MediaMimeType,
			&i.LocationLatitude,
			&i.LocationLongitude,
			&i.LocationAddress,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.EditedAt,
			&i.DeletedAt,
			&i.SenderID_2,
			&i.SenderName,
			&i.SenderEmail,
			&i.SenderAvatarUrl,
			&i.SenderCreatedAt,
			&i.SenderUpdatedAt,
			&i.ReplyID,
			&i.ReplyContent,
			&i.ReplyMessageType,
			&i.ReplySenderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
