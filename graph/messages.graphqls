
enum ConversationTypeEnum {
  DIRECT
  GROUP
}

enum MessageTypeEnum {
  TEXT
  IMAGE
  FILE
}

type Conversation {
  id: ID!
  type: ConversationTypeEnum!
  name: String
  description: String
  avatarUrl: String
  createdAt: Time!
  updatedAt: Time!
}

type ConversationListItemDirect {
  id: ID!
  type: ConversationTypeEnum!
  lastMessage: Message
  unreadCount: Int!
  createdAt: Time!
  updatedAt: Time!
}

type ConversationListItemGroup {
  id: ID!
  type: ConversationTypeEnum!
  lastMessage: Message
  unreadCount: Int!
  createdAt: Time!
  updatedAt: Time!
}

type ConversationParticipant {
  id: ID!
  user: User!
  joinedAt: Time!
  lastReadAt: Time
  isActive: Boolean!
}

type ReplyMessage {
  id: ID!
  senderName: String!
  content: String!
  messageType: MessageTypeEnum!
}

type Message {
  id: ID!
  sender: User!
  content: String!
  messageType: MessageTypeEnum!
  createdAt: Time!
  editedAt: Time
  replyToMessage: ReplyMessage
}

# =================== Queries  ===================
input ConversationMessageInput {
  conversationId: ID!
  pagination: Pagination
}

input GetOrCreateDirectConversationInput {
  userId: ID!
}

union ConversationListItem = ConversationListItemDirect | ConversationListItemGroup

type MyConversationsQuerySuccess implements Success {
  success: Boolean!
  conversations: [ConversationListItem!]!
}

union MyConversationsQueryResult = MyConversationsQuerySuccess | ServerError | UnauthorizedError

type ConversationMessagesQuerySuccess implements Success {
  success: Boolean!
  messages: [Message!]!
}

union ConversationMessagesQueryResult = ConversationMessagesQuerySuccess | ServerError | UnauthorizedError | NotFoundError

type GetOrCreateDirectConversationSuccess implements Success {
  success: Boolean!
  conversation: Conversation!
}

union GetOrCreateDirectConversationResult = GetOrCreateDirectConversationSuccess | ServerError | UnauthorizedError | NotFoundError

extend type Query {
  myConversations: MyConversationsQueryResult!
  conversationMessages(input: ConversationMessageInput!): ConversationMessagesQueryResult!
  getOrCreateDirectConversation(input: GetOrCreateDirectConversationInput!): GetOrCreateDirectConversationResult!
}

# =================== Mutations ===================

input SendMessageInput {
  conversationId: ID!
  senderID: ID!
  content: String!
  messageType: MessageTypeEnum!
  replyToMessageId: ID
}

input MarkConversationAsReadInput {
  conversationId: ID!
}

input EditMessageInput {
  messageId: ID!
  content: String!
}

type SendMessageSuccess implements Success {
  success: Boolean!
  # we don't return the message here because it's not needed for the client
  # message: Message!
}

union SendMessageResult = SendMessageSuccess | ServerError | UnauthorizedError | NotFoundError

type MarkConversationAsReadSuccess implements Success {
  success: Boolean!
  conversation: ConversationListItem!
}

union MarkConversationAsReadResult = MarkConversationAsReadSuccess | ServerError | UnauthorizedError | NotFoundError

type EditMessageSuccess implements Success {
  success: Boolean!
  message: Message!
}

union EditMessageResult = EditMessageSuccess | ServerError | UnauthorizedError | NotFoundError

# Create a 1:1 conversation
input StartDirectConversationInput {
  participantId: ID!
}

type StartDirectConversationSuccess implements Success {
  success: Boolean!
  conversation: Conversation!
}

union StartDirectConversationResult = StartDirectConversationSuccess | ServerError | UnauthorizedError | NotFoundError


extend type Mutation {
  sendMessage(input: SendMessageInput!): SendMessageResult!
  markConversationAsRead(input: MarkConversationAsReadInput!): MarkConversationAsReadResult!
  editMessage(input: EditMessageInput!): EditMessageResult!
  startDirectConversation(input: StartDirectConversationInput!): StartDirectConversationResult!
}

# =================== Subscriptions ===================

input MessageAddedSubscriptionInput {
  userId: ID!
}

input ConversationUpdatedSubscriptionInput {
  userId: ID!
}

input UserTypingSubscriptionInput {
  conversationId: ID!
}

type TypingEvent {
  writingBy: ID!
  writingAt: Time!
}

extend type Subscription {
  # Listen for new messages in user's conversations
  messageAdded(input: MessageAddedSubscriptionInput!): Message!
  # Listen for conversation updated (last message, unread counts, etc)
  conversationUpdated(input: ConversationUpdatedSubscriptionInput!): ConversationListItem!
  # Listen for typing indicators
  userTyping(input: UserTypingSubscriptionInput!): TypingEvent!
}