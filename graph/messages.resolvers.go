package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"errors"
	"fmt"
	customerrors "golang-whatsapp-clone/errors"
	"golang-whatsapp-clone/graph/model"
)

// LastMessage is the resolver for the lastMessage field.
func (r *conversationListItemDirectResolver) LastMessage(ctx context.Context, obj *model.ConversationListItemDirect) (*model.Message, error) {
	lastMessage, err := r.ConversationService.GetLastMessageFromConversation(ctx, obj.ID)
	if err != nil {
		return nil, nil
	}

	if lastMessage == nil {
		return nil, nil
	}

	return &model.Message{
		ID:          lastMessage.ID.String(),
		Content:     lastMessage.Content,
		MessageType: model.MessageTypeEnum(lastMessage.MessageType),
		CreatedAt:   lastMessage.CreatedAt.Time,
		EditedAt:    &lastMessage.EditedAt.Time,
		Sender: &model.User{
			ID:        lastMessage.SenderID.String(),
			Name:      &lastMessage.SenderName.String,
			Email:     lastMessage.SenderEmail,
			AvatarURL: &lastMessage.SenderAvatarUrl.String,
			CreatedAt: lastMessage.SenderCreatedAt.Time,
			UpdatedAt: lastMessage.SenderUpdatedAt.Time,
		},
	}, nil
}

// LastMessage is the resolver for the lastMessage field.
func (r *conversationListItemGroupResolver) LastMessage(ctx context.Context, obj *model.ConversationListItemGroup) (*model.Message, error) {
	panic(fmt.Errorf("not implemented: LastMessage - lastMessage"))
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, input model.SendMessageInput) (model.SendMessageResult, error) {
	_, graphqlError := r.mustGetAuthenticatedUser(ctx)
	if graphqlError != nil {
		return graphqlError, nil
	}

	_, err := r.MessageService.CreateMessage(
		ctx,
		input.ConversationID,
		input.SenderID,
		input.Content,
		string(input.MessageType),
		input.ReplyToMessageID,
	)

	if err != nil {
		return model.ServerError{
			ErrorMessage: "Error to send the message",
			Code:         customerrors.CodeInternalError,
		}, nil
	}

	return &model.SendMessageSuccess{Success: true}, nil
}

// MarkConversationAsRead is the resolver for the markConversationAsRead field.
func (r *mutationResolver) MarkConversationAsRead(ctx context.Context, input model.MarkConversationAsReadInput) (model.MarkConversationAsReadResult, error) {
	panic(fmt.Errorf("not implemented: MarkConversationAsRead - markConversationAsRead"))
}

// EditMessage is the resolver for the editMessage field.
func (r *mutationResolver) EditMessage(ctx context.Context, input model.EditMessageInput) (model.EditMessageResult, error) {
	panic(fmt.Errorf("not implemented: EditMessage - editMessage"))
}

// StartDirectConversation is the resolver for the startDirectConversation field.
func (r *mutationResolver) StartDirectConversation(ctx context.Context, input model.StartDirectConversationInput) (model.StartDirectConversationResult, error) {
	user, graphqlError := r.mustGetAuthenticatedUser(ctx)

	if graphqlError != nil {
		return graphqlError, nil
	}

	conversation, err := r.ConversationService.GetOrCreateDirectConversation(ctx, user.UserID, input.ParticipantID)

	if err != nil {
		return model.ServerError{
			ErrorMessage: "Error to create the conversation",
			Code:         customerrors.CodeInternalError,
		}, nil
	}

	conversationType := model.ConversationTypeEnumDirect
	if conversation.Type == model.ConversationTypeEnumGroup.String() {
		conversationType = model.ConversationTypeEnumGroup
	}

	return model.StartDirectConversationSuccess{
		Success: true,
		Conversation: &model.Conversation{
			ID:        conversation.ID.String(),
			Type:      conversationType,
			Name:      &conversation.Name.String,
			AvatarURL: &conversation.AvatarUrl.String,
			CreatedAt: conversation.CreatedAt.Time,
			UpdatedAt: conversation.UpdatedAt.Time,
		},
	}, nil
}

// MyConversations is the resolver for the myConversations field.
func (r *queryResolver) MyConversations(ctx context.Context) (model.MyConversationsQueryResult, error) {
	user, graphqlError := r.mustGetAuthenticatedUser(ctx)

	if graphqlError != nil {
		return graphqlError, nil
	}

	myConversations, err := r.ConversationService.GetUserConversations(ctx, user.UserID)
	if err != nil {
		if errors.Is(err, customerrors.ErrInvalidUUIDValue) {
			return model.ServerError{
				ErrorMessage: "invalid user id",
				Code:         customerrors.CodeInternalError,
			}, nil
		}
	}

	conversations := []model.ConversationListItem{}

	for _, conversation := range *myConversations {

		// var lastMessage *model.Message

		// if conversation.LastMessageID.String() != "" {
		// 	lastMessage = &model.Message{
		// 		ID:        conversation.LastMessageID.String(),
		// 		Content:   conversation.LastMessageContent.String,
		// 		CreatedAt: conversation.LastMessageCreatedAt.Time,
		// 		Sender: &model.User{
		// 			ID:   conversation.LastMessageSenderID.String(),
		// 			Name: &conversation.LastMessageSenderName.String,
		// 		},
		// 	}
		// }

		conversationItem := model.ConversationListItemDirect{
			ID:   conversation.ID.String(),
			Type: (model.ConversationTypeEnum)(conversation.Type),
			// Participant: &model.ConversationParticipant{},
			// LastMessage:   lastMessage,
			UnreadCount: conversation.UnreadCount,
			CreatedAt:   conversation.CreatedAt.Time,
			UpdatedAt:   conversation.UpdatedAt.Time,
		}

		conversations = append(conversations, conversationItem)
	}

	return model.MyConversationsQuerySuccess{
		Success:       true,
		Conversations: conversations,
	}, nil
}

// ConversationMessages is the resolver for the conversationMessages field.
func (r *queryResolver) ConversationMessages(ctx context.Context, input model.ConversationMessageInput) (model.ConversationMessagesQueryResult, error) {
	_, graphqlError := r.mustGetAuthenticatedUser(ctx)
	if graphqlError != nil {
		return graphqlError, nil
	}

	messages, err := r.MessageService.GetMessages(ctx, input.ConversationID, input.Pagination.Limit, input.Pagination.Offset)

	if err != nil {
		if errors.Is(err, customerrors.ErrInvalidUUIDValue) {
			return model.ServerError{
				ErrorMessage: "the conversation id is invalid",
				Code:         customerrors.CodeInternalError,
			}, nil
		}

		return model.ServerError{
			ErrorMessage: "internal server error",
			Code:         customerrors.CodeInternalError,
		}, nil
	}

	var messageList []*model.Message

	for _, value := range *messages {

		var replyMessage *model.ReplyMessage

		if value.ReplyID.String() != "" {
			replyMessage = &model.ReplyMessage{
				ID:          value.ReplyID.String(),
				SenderName:  value.ReplySenderName.String,
				Content:     value.ReplyContent.String,
				MessageType: model.MessageTypeEnum(value.ReplyMessageType.String),
			}
		}

		messageList = append(messageList, &model.Message{
			ID:             value.ID.String(),
			Content:        value.Content,
			MessageType:    model.MessageTypeEnum(value.MessageType),
			CreatedAt:      value.CreatedAt.Time,
			EditedAt:       &value.EditedAt.Time,
			ReplyToMessage: replyMessage,
			Sender: &model.User{
				ID:        value.SenderID.String(),
				Name:      &value.SenderName.String,
				Email:     value.SenderEmail,
				AvatarURL: &value.SenderAvatarUrl.String,
				CreatedAt: value.SenderCreatedAt.Time,
				UpdatedAt: value.SenderUpdatedAt.Time,
			},
		})

	}

	return &model.ConversationMessagesQuerySuccess{
		Success:  true,
		Messages: messageList,
	}, nil
}

// GetOrCreateDirectConversation is the resolver for the getOrCreateDirectConversation field.
func (r *queryResolver) GetOrCreateDirectConversation(ctx context.Context, input model.GetOrCreateDirectConversationInput) (model.GetOrCreateDirectConversationResult, error) {
	panic(fmt.Errorf("not implemented: GetOrCreateDirectConversation - getOrCreateDirectConversation"))
}

// MessageAdded is the resolver for the messageAdded field.
func (r *subscriptionResolver) MessageAdded(ctx context.Context, input model.MessageAddedSubscriptionInput) (<-chan *model.Message, error) {
	panic(fmt.Errorf("not implemented: MessageAdded - messageAdded"))
}

// ConversationUpdated is the resolver for the conversationUpdated field.
func (r *subscriptionResolver) ConversationUpdated(ctx context.Context, input model.ConversationUpdatedSubscriptionInput) (<-chan model.ConversationListItem, error) {
	panic(fmt.Errorf("not implemented: ConversationUpdated - conversationUpdated"))
}

// UserTyping is the resolver for the userTyping field.
func (r *subscriptionResolver) UserTyping(ctx context.Context, input model.UserTypingSubscriptionInput) (<-chan *model.TypingEvent, error) {
	panic(fmt.Errorf("not implemented: UserTyping - userTyping"))
}

// ConversationListItemDirect returns ConversationListItemDirectResolver implementation.
func (r *Resolver) ConversationListItemDirect() ConversationListItemDirectResolver {
	return &conversationListItemDirectResolver{r}
}

// ConversationListItemGroup returns ConversationListItemGroupResolver implementation.
func (r *Resolver) ConversationListItemGroup() ConversationListItemGroupResolver {
	return &conversationListItemGroupResolver{r}
}

type conversationListItemDirectResolver struct{ *Resolver }
type conversationListItemGroupResolver struct{ *Resolver }
